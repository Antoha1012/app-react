{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useRef } from \"react\";\nexport const useObserver = (ref, canLoad, isLoading, callback, visiblePosts) => {\n  _s();\n\n  const observer = useRef();\n  useEffect(() => {\n    if (isLoading) return;\n    if (observer.current) observer.current.disconnect();\n\n    const cb = function (entries, observer) {\n      if (entries[0].isIntersecting && canLoad) {\n        setTimeout(() => {\n          callback(visiblePosts);\n        }, 50);\n      }\n    };\n\n    observer.current = new IntersectionObserver(cb);\n    observer.current.observe(ref.current);\n  }, [isLoading, visiblePosts]);\n};\n\n_s(useObserver, \"mvUvGhiqkPzCYiMPAW/Py9ym/ZY=\");","map":{"version":3,"sources":["/Users/eugenechernomor/Downloads/optimizationProject-main/src/hooks/useObserver.js"],"names":["useEffect","useRef","useObserver","ref","canLoad","isLoading","callback","visiblePosts","observer","current","disconnect","cb","entries","isIntersecting","setTimeout","IntersectionObserver","observe"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;AAEA,OAAO,MAAMC,WAAW,GAAG,CACzBC,GADyB,EAEzBC,OAFyB,EAGzBC,SAHyB,EAIzBC,QAJyB,EAKzBC,YALyB,KAMtB;AAAA;;AACH,QAAMC,QAAQ,GAAGP,MAAM,EAAvB;AAEAD,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIK,SAAJ,EAAe;AACf,QAAIG,QAAQ,CAACC,OAAb,EAAsBD,QAAQ,CAACC,OAAT,CAAiBC,UAAjB;;AAEtB,UAAMC,EAAE,GAAG,UAAUC,OAAV,EAAmBJ,QAAnB,EAA6B;AACtC,UAAII,OAAO,CAAC,CAAD,CAAP,CAAWC,cAAX,IAA6BT,OAAjC,EAA0C;AACxCU,QAAAA,UAAU,CAAC,MAAM;AACfR,UAAAA,QAAQ,CAACC,YAAD,CAAR;AACD,SAFS,EAEP,EAFO,CAAV;AAGD;AACF,KAND;;AAOAC,IAAAA,QAAQ,CAACC,OAAT,GAAmB,IAAIM,oBAAJ,CAAyBJ,EAAzB,CAAnB;AACAH,IAAAA,QAAQ,CAACC,OAAT,CAAiBO,OAAjB,CAAyBb,GAAG,CAACM,OAA7B;AACD,GAbQ,EAaN,CAACJ,SAAD,EAAYE,YAAZ,CAbM,CAAT;AAcD,CAvBM;;GAAML,W","sourcesContent":["import { useEffect, useRef } from \"react\";\n\nexport const useObserver = (\n  ref,\n  canLoad,\n  isLoading,\n  callback,\n  visiblePosts\n) => {\n  const observer = useRef();\n\n  useEffect(() => {\n    if (isLoading) return;\n    if (observer.current) observer.current.disconnect();\n\n    const cb = function (entries, observer) {\n      if (entries[0].isIntersecting && canLoad) {\n        setTimeout(() => {\n          callback(visiblePosts);\n        }, 50);\n      }\n    };\n    observer.current = new IntersectionObserver(cb);\n    observer.current.observe(ref.current);\n  }, [isLoading, visiblePosts]);\n};\n"]},"metadata":{},"sourceType":"module"}